#SDK для работы с API Контур.Экстерна для платформы JVM 

##1.Назначение
Предназначен для легкой интеграции внешних систем с API Контур.Экстерна, разработанных для платформы JVM. Для этого библиотека предоставляет класс ExternEngine, с помощью которого производится передача данных на внешние сервисы СКБ Контур. Класс ExternEngine включает в себя следующие сервисы:

- AccountService – сервис для работы с аккаунтами конечных пользователей: 
		получить аккаунт
		создать новый аккаунтам;
- DraftService – сервис для работы с черновиками;
- DocflowService – сервис для работы с документооборотами;
- CertificateService – сервис для работы с сертификатами.

##2.Конфигурирование
Для того чтобы начать работу с SDK, необходимо создать и сконфигурировать объект ExternEngine. Для конфигурации необходимо создать и передать с помощью соответствующего сеттера следующие провайдеры:

- **ServiceBaseUriProvider** – предоставляет адрес сервиса в Интернет. Провайдер представляет из себя объект, имплементирующий метод getServiceBaseUri интерфейса ServiceBaseUriProvider, возвращающий URI сервиса. В простейшем случае вы можете передать лямбда-выражение типа: ()->”https://...”;

- **AccountProvider** — предоставляет идентификатор аккаунта, который передается при отправки данных на сервис. Данный идентификатор связан с лицевым счетом в системе СКБ Контур. Провайдер представляет из себя объект, имплементирующий метод *accountId* интерфейса *AccountProvider*. В простейшем случае вы можете передать лямбда-выражение типа:     ()->"XXXXXXXX-XXXX-XXXX-XXXX-XXXXXXXXXXXX";

- **ApiKeyProvider** – предоставляет идентификатор, который присваивается организации, от которой отправляются запросы к сервисам. Провайдер представляет из себя объект, имплементирующий метод getApiKey интерфейса ApiKeyProvider. Также может из себя представлять лямбда-выражение типа:     ()->"XXXXXXXX-XXXX-XXXX-XXXX-XXXXXXXXXXXX";

- **CryptoProvider** – предоставляет криптографический провайдер. В SDK есть три реализации:
    * реализация для работы с [MSCapi](https://msdn.microsoft.com/en-us/library/windows/desktop/aa380256.aspx) - класс *CryptoProviderMSCap*
    * реализация для [облачной криптографии](https://wiki.skbkontur.ru/display/KE/CloudCryptApi) - класс *CloudCryptoProvider*;
    * реализация для RSA криптографии *CryptoProviderRSA*.

Первая (MSCAPI) и вторая (облачная) реализации криптографии предназначены для вычисления электронной подписи и расшифрования зашифрованных документов, с использованием алгоритмов ГОСТ. Третья (RSA) предназначена для подписания идентификационных данных для доверительной аутентификации, с использованием алгоритмов RSA;

- **AuthenticationProvider** — предоставляет аутентификатор. Каждый запрос, отправляемый к сервисам СКБ Контур, должен сопровождаться токеном аутентификации. Аутентифицироваться можно:
    * [по логину и паролю](https://wiki.skbkontur.ru/pages/viewpage.action?pageId=148353776). Для этого в SDK есть класс AuthenticationProviderByPass, реализующий интерфейс *AuthenticationProvider*.
    * с помощью [доверительной аутентификации](https://wiki.skbkontur.ru/pages/viewpage.action?pageId=148355220). Для этого в SDK реализован класс *TrustedAuthentication*, так-же реализующий интерфейс *AuthenticationProvider*.

###2.1.Конфигурирование криптопровайдеров

1. MSCAPI криптопровайдер

    * Назначение
Предназначен для выполнения криптографических операций на компьютере клиента с помощью сертифицированного криптопровайдера с использованием **ГОСТ** алгоритмов, например **КриптоПро**. Для расшифрования и вычисления электронной подписи требуется доступный ключевой носитель, содержащий сертификат открытого ключа.
    * Создание и конфигурирование
Для создания объекта достаточно вызвать конструктор класса *CryptoProviderMSCapi*. Дальнейшее конфигурирование не требуется.

2. Облачный криптопровайдер

	* Назначение
Предназначен для выполнения криптографических операций на сервере с использованием **ГОСТ** алгоритмов. Клиент делегирует выполнение криптографических операций специальному сервису. Криптографические операции: вычисление подписи и расшифрование выполняются в два этапа:
		* 1 этап - это запрос на выполнение операции; 
		* 2 этап – подтверждение операции СМС–кодом. 
		На первом этапе сервис принимает запрос и возвращает идентификатор запроса. На втором этапе сервис ожидает идентификатор запроса, который был отдан, и СМС-код.
	* Создание и конфигурация
Для работы с облачной криптографией необходимо создать объект *CloudCryptoProvider* с помощью конструктора, передав в него, адрес  облачного сервиса. Для полученного объекта необходимо установить:
		+ *AuthenticationProvider* – провайдер для получения токена аутентификации. Назначение аутентификации и типы были описаны выше.
		+ *ApiKeyProvider* – провайдер для получения идентификатора организации. Описание см. выше.
		+ *CertificateProvider* – провайдер предназначен для получения сертификат отправителя в DER кодировки по его отпечатку из внутреннего хранилища внешней системы. Данный провайдер должен имплементировать интерфейс типа: `Function<String, byte[]>`.
		+ *ApproveCodeProvider* – провайдер предназначен для получения СМС-кода, который отправляется облачным сервисом на зарегистрированный номер телефона отправителя. Данный провайдер должен имплементировать интерфейс типа: `Function<String, String>`, где параметром является идентификатор запроса, а возвращаемым значением – СМС-код.

3. RSA криптопровайдер

	* Назначение
Предназначен для вычисления ЭП с использованием **RSA** алгоритмов. Данный криптопровайдер может быть использован для доверительной аутентификации.
	* Создание и конфигурация
Для работы с **RSA** подписью необходимо создать объект типа *CryptoProviderRSA* с помощью конструктора. Конструктор принимает на вход пароль для ключевого хранилища **JAVA** (**JKS**) и пароль для секретного ключа. Если в качестве паролей передать значение **null**, то это будет означать его отсутствие.  Для полученного объекта можно установить провайдер *KeyStoreProvider* типа **`Supplier<String>`**, который возвращает путь к **JKS**. По умолчанию криптопровайдер использует **JKS java runtime**: `System.getProperty("java.home")+File.separator+"lib"+File.separator+"security"+File.separator+"cacerts"`.

###2.1.Конфигурирование аутентификаторов

1. Аутентификация по логину и паролю

	- Для аутентификации по логину и паролю необходимо создать объект класса AuthenticationProviderByPass с помощью конструктора. Конструктор принимает четыре параметра:
		- *authBaseUriProvider* : *UriProvider* – URI провайдер, возвращает адрес сервиса аутентификации. В простейшем случае можно использовать лямбда-выражение: `()->"https://...”`;
		- *loginAndPasswordProvider* : *LoginAndPasswordProvider* – объект, реализующий соответствующий интерфейс, возвращающий логин и пароль пользователя из внешней системы;
		- apiKeyProvider : ApiKeyProvider. Описание см. выше.
		- authPrefix : String – строка, содержащая префикс для передачи токена аутентификации. Если данный параметр опустить, то будет использовано значение по умолчанию: "auth.sid "

2. Доверительная аутентификация 

	- Для доверительной аутентификации необходимо создать объект класса *TrustedAuthentication* с помощью конструктора, передав ему параметр *authPrefix*, Описание назначения параметра *authPrefix* см. выше.  Для полученного объекта с помощью соответствующих сеттеров необходимо установить следующие провайдеры:
		- *ApiKeyProvider* – провайдер для получения идентификатора организации. Описание см. выше.
		- *authBaseUriProvider* : *UriProvider* – **URI** провайдер, возвращает адрес сервиса аутентификации. В простейшем случае можно использовать лямбда-выражение: `()->"https://...”`;
		- *CryptoProvider* – предоставляет криптографический провайдер. Можно установить либо **MSCAPI** провайдер, либо **RSA** криптопровайдер. Для того чтобы можно доверительно аутентифицироваться, необходимо зарегистрировать сертификат в сервисе доверительной аутентификации. Для этого необходимо обратиться в СКБ Контур.
		- *SignatureKeyProvider* – предоставляет отпечаток сертификата ключа, с помощью которого будут подписываться идентификационный данные конечного пользователя (отправителя). В простейшем случае можно использовать лямбда-выражение: `()->”XXXXXXXXXXXXXXXXXXXX”`;
		- *ServiceUserIdProvider* – предоставляет идентификатор конечного пользователя во внешней системе. В простейшем случае можно использовать лямбда-выражение: `()->”XXXXXXXX-XXXX-XXXX-XXXX-XXXXXXXXXXXX”`;
		- *CredentialProvider* – предоставляет структуру данных содержащий наименования идентификатора (СНИЛС, номер телефона) и его значение. В простейшем случае можно использовать лямбда-выражение:` ()->new Credential(”phone”,”03”)`. Подробнее можно прочитать здесь: https://wiki.skbkontur.ru/pages/viewpage.action?pageId=148355220;



